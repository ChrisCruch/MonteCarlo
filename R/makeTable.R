
#######################################################################################################################################
#
#   MakeTable generates tables from output of MonteCarlo that can be directly copied to Latex.
#   The ordering of the variables to columns and rows can be determined by user.
#
#######################################################################################################################################



#' helper function to create index string
#' @keywords internal
make.index<-function(letter,number){
  help<-paste(paste(letter,1:number,",",sep=""),collapse="")
  help<-substr(help,1,(nchar(help)-1))
  help
}


#' helper function to average over results from MonteCarlo() run
#' @keywords internal
collapse.results<-function(output, collapse){
ret<-list()
for(i in 1:length(output)){
out<-output[[i]]
num.param<-length(dim(out))-1
help<-make.index("i",num.param)
erg<-array(NA,dim=dim(out)[1:num.param])
loop<-paste(paste(paste("for(i",1:num.param," in 1:",dim(out)[1:num.param],"){", sep=""), collapse=""),paste(c("erg[",help,"]<-"), collapse=""),
            paste(c(collapse[[i]],"(na.omit(out[",help,",]))"),collapse=""),paste(rep("}",num.param),collapse=""),collapse="")
eval(parse(text=loop))
dimnames(erg)<-dimnames(out)[1:num.param]
ret[[i]]<-erg
}
names(ret)<-names(output)
ret
}


########### helper functions #################

# assign variables to make.Table function environment and replace the respective code parts DRY!!

#namesNstuff<-function(){
#  dims<-dim(out)
#  n.dims<-length(dims)
#  all.names<-dimnames(out)
#  dim.names<-0
#  for(i in 1:length(all.names)){dim.names[i]<-unlist(strsplit(all.names[[i]], split="="))[1]
#}


##########################           MakeTable             ####################################

#' @title Create Latex tables from MonteCarlo output.
#' @description \code{MakeTable} generates Latex tables with user determined ordering from output of MonteCarlo function.
#' @details add details
#' parameter grids of length one are dropped from table (unless they are the only value in either cols or rows) and values are added to caption
#' to stack list elements in rows or columns add "list" to vector \code{rows} or \code{cols}.
#' @param output output list generated by MonteCarlo
#' @param param.list list of parameter grid that was pased to \code{MonteCarlo} to obtain output.
#' @param rows vector of parameter names that are supposed to be stacked in the rows of the table. Ordered from inner to outer.
#' @param cols vector of parameter names that are supposed to be stacked in the cols of the table. Ordered from inner to outer.
#' @param digits maximal number of digits displayed in table. Default is \code{digits=4}.
#' @param collapse either \code{NULL} or a list of the same as \code{output} giving the names of functions to be applied to the 
#' repective components of \code{output} when collapsing results to table. By default means are taken. Another example could be \code{sd()}.
#' @param Transform optional argument to transform the output table (for example from MSE to RMSE). If a function is supplied
#' it is applied to all tables. Alternatively, a list of functions can be supplied that has the same length as \code{output}. 
#' For tables that are supposed to stay unchanged set list element to \code{NULL}.
#' @param func function evaluated by \code{MonteCarlo} can optionally be supplied, 
#' so that the function is printed as a commented verbatim after the table. Can be useful for future reference to parameter
#' specifications within \code{func}.
#' MakeTable<-function(output, rows, cols, digits=4, Transform=NULL, func=NULL)
#' @param width.mult scaling factor for width of the output table 
#' @examples
#' library(mvtnorm)
#' reg.func<-function(T,sdx,sig.noise,sig.eps,rho){
#' mux<-0
#' beta0<-0
#' beta1<-1
#' cov_noise_e<-sig.noise*sig.eps*rho
#' noise_e<-rmvnorm(T, mean=c(0,0), sigma=matrix(c(sig.noise^2,cov_noise_e,cov_noise_e,sig.eps^2),2,2))
#' x<-rnorm(T,mux,sdx)
#' noise<-noise_e[,1]
#' eps<-noise_e[,2]
#' X<-cbind(1,x+noise)
#' beta<-c(beta0,beta1)
#' y<-X%*%beta+eps
#' beta.hat<-solve(t(X)%*%X)%*%t(X)%*%y
#' sig.eps2.hat<-mean((y-X%*%beta.hat)^2)
#' sd.beta<-sqrt(diag(sig.eps2.hat*solve(t(X)%*%X)))
#' bias<-beta-beta.hat
#' test<-abs((beta.hat[2]-beta1)/sd.beta)>1.96
#' return(list("bias"=bias[2],"test"=test[2]))
#' }
#' T.grid<-c(50,100)
#' sdx.grid<-c(1,2)
#' sig.noise.grid<-c(0.1,1)
#' sig.eps.grid<-c(1,2)
#' rho.grid<-c(-0.5,0.5)
#' param.list=list("T"=T.grid, "sdx"=sdx.grid,"sig.noise"=sig.noise.grid, "sig.eps"=sig.eps.grid, "rho"=rho.grid)
#' output<-MonteCarlo(func=reg.func, M=250, param.list=param.list, ncpus=1, timeNtest=FALSE, save.res=FALSE, raw=TRUE, max.grid<-5000)
#' rows<-c("rho", "sig.noise", "sdx")
#' cols<-c("sig.eps","T")
#' MakeTable(output, rows, cols, digits=2)
#'@export

MakeTable<-function(output, param.list, rows, cols, digits=4, collapse=NULL, Transform=NULL, func=NULL, width.mult=1){
   
  for(i in 1:length(param.list)){assign(paste(names(param.list)[i],".grid",sep=""),param.list[[i]])}
  
  if(is.list(output)==FALSE)stop("Output has to be a list that is the output of MonteCarlo().")
  if(any(rows%in%cols))stop("Names in rows and cols must be unique.")
  
  if(is.null(collapse)){
    collapse<-list()
    for(i in 1:length(output)){collapse[[i]]<-"mean"}
  }

  output<-collapse.results(output, collapse=collapse) # from raw output average over results, so that monte carlo results are saved in list of large arrays
  
  # apply function(s) passed through transform to output


  if(is.null(Transform)==FALSE){
    if(any(c(is.function(Transform), is.list(Transform)))==FALSE)stop("Transform must be either NULL, a function or a list of functions!")
    if(is.list(Transform)){if(length(Transform)!=length(output))stop("List supplied as Transform must be of the same lengths as output.")}
    if(length(Transform)==1){ # if only a single function is passed to MakeTable apply it to each array in collapsed output list      
      help<-list()
      for(i in 1:length(output)){help[[i]]<-Transform} # convert Transform to list of functions that repeats the function Transform
      Transform<-help
    }
      for(i in 1:length(output)){
      if(is.null(Transform[[i]])==FALSE){output[[i]]<-Transform[[i]](output[[i]])} # apply i-th element of function list to i-th output array
    }
  }
  
  
  output.aux<-NULL
  if("list"%in%unique(c(rows,cols))){
    for(i in 1:length(output)){
    output.aux<-abind(output.aux, output[[i]], along=(length(dim(output[[1]]))+1))
    }
  dimnames.aux<-dimnames(output[[1]])
  dimnames.aux[[(length(dim(output[[1]]))+1)]]<-paste("list=",names(output), sep="")
  dimnames(output.aux)<-dimnames.aux
  param.list$list<-names(output)
  list.grid<-names(output)
  output<-list(output.aux)
  }

  
  
  for(lll in 1:length(output)){   # iterate over list elements to create own table for each variable returned by function fun
  
  out<-output[[lll]]  # select element from list.
    
  if(length(dim(out))==1){
    if(is.null(rows)){
      aux_dimnames<-list()
      aux_dimnames[[1]]<-""
      aux_dimnames[[2]]<-dimnames(out)[[1]]
      out<-array(out, dim=c(1,dim(out)))
    }
    if(is.null(cols)){
      aux_dimnames<-list()
      aux_dimnames[[1]]<-dimnames(out)[[1]]
      aux_dimnames[[2]]<-""
      out<-array(out, dim=c(dim(out),1))
    }
    dimnames(out)<-aux_dimnames
  }  

  
  ## drop all dimensions from out-array that are equal to 1 (and thus unneccesary) and pass parameter information to description
  pass.to.info<-NULL
  if(length(dim(out))>2){
  if(any(dim(out)==1)){
    
    select<-which(dim(out)==1)
    
    ####
    rows.in.out<-which(names(param.list)%in%rows)
    cols.in.out<-which(names(param.list)%in%cols)
    
    select.rows<-select[which(select%in%rows.in.out)]
    select.cols<-select[which(select%in%cols.in.out)]
    
    if(length(cols)-length(select.cols)==0){select.cols<-select.cols[select.cols!=cols.in.out[1]]}
    if(length(rows)-length(select.rows)==0){select.rows<-select.rows[select.rows!=rows.in.out[1]]}
    select<-c(select.rows, select.cols) 
    if(length(select)>0){
    ####
    
    pass.to.info<-as.character(dimnames(out)[select]) # add parameter info about dropped dimensions to caption
    dims<-dim(out)
    n.dims<-length(dims)
    sel.str<-"out<-array(out["
    for(i in 1:n.dims){sel.str<-c(sel.str,if(i<n.dims){if(dims[i]==1){"1,"}else{","}}else{if(dims[i]==1){"1"}else{""}})}
    eval(parse(text=paste(c(sel.str,"], dim=dims[-select], dimnames=dimnames(out)[-select])"), collapse="")))
    p.name<-unlist(strsplit(pass.to.info, split="="))[-(1:length(select))*2]  
    if(any(p.name%in%rows)){rows<-rows[-which(rows%in%p.name)]}
    if(any(p.name%in%cols)){cols<-cols[-which(cols%in%p.name)]}
    }#
  }
  }
    
  
  

 ### escape special characters
 
 pass.to.info<-gsub(pattern="_", replacement=paste("\\\\","_", sep=""), pass.to.info)
 
 ###
  
  #----- replace this part with helper function
  dims<-dim(out)
  n.dims<-length(dims)
  all.names<-dimnames(out)
  dim.names<-0
  for(i in 1:length(all.names)){dim.names[i]<-unlist(strsplit(all.names[[i]], split="="))[1]}
  #----------------------------------------------------------------------------------------------#
  
  if(any(na.omit(dim.names)%in%c(rows,cols)==FALSE))stop("rows and cols must contain all parameter names unless the grid has only one value.")
 
  ###--- rearrange array so that first dimension corresponds to first variable for row selected and 
  ###--- second dimension has to correspond to first column selected
  
  if(length(dim(out))>1){
  sel<-c(which(dim.names==rows[1]),which(dim.names==cols[1]))
  help.vec<-1:n.dims
  perm<-c(sel,help.vec[-which(help.vec%in%sel)])
  out<-aperm(out,perm=perm)
  }

  #----- replace this part with helper function
  dims<-dim(out)
  all.names<-dimnames(out)
  dim.names<-0
  for(i in 1:length(all.names)){dim.names[i]<-unlist(strsplit(all.names[[i]], split="="))[1]}
  #----------------------------------------------------------------------------------------------#
  
  ###------------ construct index for interation over dimensions of out
  ###------------ make vectors that contain grid lengths for all variables in rows and columns but the first in each 
  ind<-rep("NA",(n.dims))
  col.dims<-row.dims<-NULL
  if(length(rows)>1){
  for(i in 2:length(rows)){
    sel.row<-(which(dim.names==rows[i]))
    ind[sel.row]<-paste("i",i-1, sep="")
    row.dims<-c(row.dims,dims[sel.row])     # dim of array corresponds to length of grid
  }}
  if(length(cols)>1){
  for(j in 2:length(cols)){
    sel.col<-(which(dim.names==cols[j]))
    ind[sel.col]<-paste("j",j-1, sep="")
    col.dims<-c(col.dims,dims[sel.col])
  }}
  ind<-paste(ind[-c(1,2)], collapse=",")    # ignore the first two dimensions since these are fixed

  #############     Construct loops to generate matrix in the order specified by rows and cols    #################
  
  loops.rows<-length(rows)-1  # determine number of loops for rows
  loops.cols<-length(cols)-1  # determine number of loops for columns

  ## inner loop runs over rows. if one block is completed the outer grid combines block of rows to columns
  ## the elementary building block is the matrix consisting of the first two dimensions of out, 
  ## that correspond to the first row and the first column specified by the user.
  ## between all rows of these matrices a row of NAs is added.
  ## when columns are combined in the outer loop, columns are also seperated using a column of NAs
  
  if(length(dim(out))>2){ 
  inner.cols<-NULL
  build.string<-paste(c(
    if(loops.cols>0){paste("for(j",loops.cols:1," in 1:","col.dims[",loops.cols:1,"]){", sep="")}else{""},
    "inner.rows<-NULL;",
    if(loops.rows>0){paste("for(i",loops.rows:1," in 1:","row.dims[",loops.rows:1,"]){", sep="")}else{""},
    paste("inner.rows<-rbind(inner.rows,matrix(out[,,",ind,"],dims[1],dims[2]),rep(NA,dims[2]))"),
    rep("}",loops.rows),
    ";",
    "inner.cols<-cbind(inner.cols,inner.rows,rep(NA,dims[1]+1))",
    rep("}",loops.cols)), collapse="")
  eval(parse(text=build.string))
  erg.mat<-(inner.cols)
  }else{
  erg.mat<-rbind(cbind(out,NA),NA)
  }

  ###------  for better readability add column of NAs between blocks for each grid value of the third column variable
  
  if(length(cols)>2){
  count.col<-dims[2]*col.dims[1]+col.dims[1]
  rep.col<-dim(erg.mat)[2]/count.col
  startstop.col<-matrix(NA,rep.col,2)
  for(i in 1:rep.col){
    startstop.col[i,]<-c((i-1)*count.col+1,i*count.col)
  }
  erg.mat2<-matrix(NA,nrow(erg.mat),ncol(erg.mat)+rep.col)
  for(i in 1:rep.col){
    erg.mat2[,((startstop.col[i,1]+(i-1)):(startstop.col[i,2]+(i-1)))]<-erg.mat[,(startstop.col[i,1]:startstop.col[i,2])] 
  }
  erg.mat<-erg.mat2
  }
 
  ###------  for better readability add row of NAs between blocks for each grid value of the third row variable
  
  if(length(rows)>2){
  count.row<-dims[1]*row.dims[1]+row.dims[1]
  rep.row<-dim(erg.mat)[1]/count.row
  startstop.row<-matrix(NA,rep.row,2)
  for(i in 1:rep.row){startstop.row[i,]<-c((i-1)*count.row+1,i*count.row)}
  erg.mat3<-matrix(NA,nrow(erg.mat)+rep.row,ncol(erg.mat))
  for(i in 1:rep.row){erg.mat3[((startstop.row[i,1]+(i-1)):(startstop.row[i,2]+(i-1))),]<-erg.mat[(startstop.row[i,1]:startstop.row[i,2]),]}
  erg.mat<-erg.mat3
  }
  
  ############################################################
  
  # Note that descriptions for rows and columns are handled differently due to the different behaviour of
  # multicolumn and multirow in latex. since multirow fits in one column, the descriptions for the rows can
  # simply be included in the matrix that is supposed to be printed later.
  # multicolumn on the other hand requires the omission of "&"s, so that they fit into latex array. headers for
  # the columns are therefore collected in seperate list
  
  heads<-list()
  
  # inner header
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 
  if(length(cols)>1){
  help.head1<-eval(parse(text=paste("rep(c(paste(",paste(cols[1],".grid",sep=""),"),NA),col.dims[1])",sep="")))
  head1<-rep(c(help.head1,if(length(cols)>2){NA}else{NULL}),prod(col.dims[-1]))
  }else{if(is.null(cols)){head1<-c("",NA)}else{head1<-c(paste(get(paste(cols[1],".grid",sep=""))),NA)}
  }
  heads[[1]]<-head1
  
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 
  # inner rownames
  
  if(length(rows)>1){
    help.rows1<-eval(parse(text=paste("rep(c(paste(",paste(rows[1],".grid",sep=""),"),NA),row.dims[1])",sep="")))
  }else{if(is.null(rows)){help.rows1<-c("",NA)}else{help.rows1<-eval(parse(text=paste("rep(c(paste(",paste(rows[1],".grid",sep=""),"),NA),1)",sep="")))}}
  if(length(rows)>2){rows1<-rep(c(help.rows1,NA),prod(row.dims[-1]))}else{rows1<-help.rows1}

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 
  # inner table with names
  erg.mat4<-rbind(c(paste(rows[1],"/",cols[1], sep=""),NA,head1),rep(NA,length(head1)+2),cbind(rows1,rep(NA,length(rows1)),erg.mat))
  dimnames(erg.mat4)<-NULL
  erg.mat<-erg.mat4
  
  ################################################################################
  
  if(length(cols)>1){
  help.head2<-eval(parse(text=paste("paste('\\\\multicolumn{'",",","dims[2]",",","'}{c}{'",",",paste(cols[2],".grid",sep=""),",","'}'",")")))
  help.head2b<-rep(NA,2*col.dims[1]-1)
  help.head2b[seq(1,length(help.head2b),2)]<-help.head2
  head2<-rep(c(help.head2b,rep(NA,2)),prod(col.dims[-1]))
  heads[[2]]<-head2
  }
  
  n.multicol<-c(1,dims[2])
  if(length(cols)>2){
    for(i in 3:length(cols)){
      col.mult<-if(i==3){1}else{2}
      n.multicol[i]<-(n.multicol[(i-1)]+col.mult)*col.dims[(i-2)]-col.mult
      assign(paste("help.head",i,sep=""),eval(parse(text=paste("paste('\\\\multicolumn{'",",","paste(n.multicol[i])",",","'}{c}{'",",",paste(cols[i],".grid",sep=""),",","'}'",")",sep=""))))
      assign(paste("head",i,sep=""),NULL)
      eval(parse(text=paste("for(j in 1:length(",paste("help.head",i,sep=""),")){",paste("head",i,sep=""),"<-c(",paste("head",i,sep=""),",",paste("help.head",i,"[j]",sep=""),",NA,NA)}")))
      heads[[i]]<-rep(get(paste("head",i,sep="")),prod(col.dims[-(1:(i-1))]))
    }
  }

  if(length(rows)>1){
  help.rows2<-eval(parse(text=paste("paste('\\\\multirow{'",",","dims[1]",",","'}{*}{'",",",paste(rows[2],".grid",sep=""),",","'}'",")"))) 
  help.rows2b<-rep(NA,length(help.rows2)*(dims[1]+1))
  help.rows2b[seq(1,length(help.rows2b),dims[1]+1)]<-help.rows2
  if(length(rows)>2){rows2<-c(rows[2],NA,rep(c(help.rows2b,NA),prod(row.dims[-1])))}else{rows2<-c(rows[2],NA,help.rows2b)}  
  }
  
  n.multirow<-c(1,dims[1])
  if(length(rows)>2){
    for(i in 3:length(rows)){
      row.mult<-if(i==3){1}else{2}
      n.multirow[i]<-(n.multirow[(i-1)]+row.mult)*row.dims[(i-2)]-row.mult
      assign(paste("help.rows",i,sep=""),eval(parse(text=paste("paste('\\\\multirow{'",",","paste(n.multirow[i])",",","'}{*}{'",",",paste(rows[i],".grid",sep=""),",","'}'",")",sep=""))))
      assign(paste("rows.help",i,sep=""),NULL)
      eval(parse(text=
      paste("for(j in 1:",paste(length(get(paste("help.rows",i,sep="")))),"){",paste("rows.help",i,sep=""),"<-c(",paste("rows.help",i,sep=""),",",paste("help.rows",i,"[j],",sep=""),paste(paste(paste(rep(NA,n.multirow[i]+1)),collapse=","),")}",collapse=""))
        ))
      assign(paste("rows",i,sep=""),c(rows[i],NA,rep(get(paste("rows.help",i,sep="")),prod(row.dims[-(1:(i-1))]))))
    }
  }

  erg.mat5<-erg.mat 
  if(length(rows)>1){for(i in 2:length(rows)){erg.mat5<-cbind(get(paste("rows",i, sep="")),erg.mat5)}}
  
  drop.col<-NULL
  for(i in 1:ncol(erg.mat5)){if(sum(is.na(erg.mat5[,ncol(erg.mat5)+1-i])==FALSE)==0){drop.col<-c(drop.col,i)}else{break}}
  drop.row<-NULL
  for(i in 1:nrow(erg.mat5)){if(sum(is.na(erg.mat5[nrow(erg.mat5)+1-i,])==FALSE)==0){drop.row<-c(drop.row,i)}else{break}}
    
  erg.mat6<-erg.mat5[-c(nrow(erg.mat5)+1-drop.row),-c(ncol(erg.mat5)+1-drop.col)]
  erg.mat7<-matrix("&",nrow(erg.mat6),ncol(erg.mat6)*2-1)
  
  ###------  reformat results so that the output is printed with digits digits
 
  aux<-erg.mat6[-c(1,2),-c(1:length(rows))]
  sel<-which(is.na(aux)==FALSE)
  aux[sel]<-format(round(as.numeric(as.vector(aux)[sel]),digits=digits), nsmall=digits, scientific=FALSE)
  erg.mat6[-c(1,2),-c(1:length(rows))]<-aux
 
  #########
 
  erg.mat7[,seq(1,ncol(erg.mat7),2)]<-erg.mat6
  erg.mat7[which(is.na(erg.mat7))]<-""

  ###------         Define all character strings needed for header and footer of the table in vectors            ########
  
  preamble<-c("\\begin{table}[h]","\n",
              "\\centering","\n",
              paste("\\resizebox{",width.mult,"\\textwidth}{!}{%", collapse=""),"\n",
              paste("\\begin{tabular}{",paste(rep("r",ncol(erg.mat7)-1), collapse=""),"}"),"\n",
              "\\hline","\\hline","\\\\","\\\\","\n")
  footer<-c("\\\\","\n","\\\\","\n","\\hline","\\hline","\n",
            "\\end{tabular}%","\n",
            "}","\n",
            paste("\\caption{",names(output)[lll],if(is.null(pass.to.info)==FALSE){paste(pass.to.info, collapse=",")}else{""},"}")
            ,"\n",
            "\\end{table}", "\n"
  )
  
  
  for(i in 1:length(heads)){
    help<-rep("&",length(heads[[i]])*2-1)       # include "&" inbetween elements in header to seperate columns of table in Latex
    help[seq(1,length(help),2)]<-heads[[i]]
    heads[[i]]<-help
    heads[[i]][which(is.na(heads[[i]]))]<-""    # replace all NA values with whitespace
  }

  ###------  escape underscore in variable names
 
  erg.mat7<-gsub(pattern="_", replacement=paste("\\\\","_", sep=""), erg.mat7)
  cols<-gsub(pattern="_", replacement=paste("\\\\","_", sep=""), cols)
 
  ###--------------------   Loops to print the table from its elements using cat -------------------###

  for(i in 1:length(preamble)){cat(preamble[i])}
  if(length(cols)>1){
    for(i in 1:(length(heads)-1)){
      cat(rep("&",length(rows)-1),paste(cols[length(heads)+1-i]),"&&",heads[[length(heads)+1-i]],"\\\\","\n")
    }}
  for(i in 1:nrow(erg.mat7)){cat(erg.mat7[i,],"\\\\","\n")}
  for(i in 1:length(footer)){cat(footer[i])}
  if(length(output)>lll){cat("\n","\n","\n")}
  
  ###------------------------------------------------------------------------------------------------###
  
  } # finish loop over all list elements in output of MonteCarlo()
 
  if(is.null(func)==FALSE){
    func.vec<-paste(as.character(body(func))[-1])
    cat("% Function:","\n")
    cat("%","\\begin{verbatim}","\n")
    for(i in 1:length(func.vec)){cat("%",func.vec[i],"\n")}
    cat("%","\\end{verbatim}")
  }
}

#######################################################################################################################################





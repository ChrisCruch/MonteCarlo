---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


# The MonteCarlo Package

Monte Carlo studies are a common tool in statistics and related fields. They are used for everything from the evaluation of the finite sample properties of new statistical methods to the generation of probability distributions for risk management.

The MonteCarlo package for the R language provides tools to create simulation studies quickly and easily and it also allows to summarize the results in LaTex tables. This paper gives details on the implementation of the MonteCarlo package and presents examples for its application.

There are only two main functions in the package:

  1. *MonteCarlo()* runs a simulation study for a user defined function and parameter grid. The package handles the generation of loops over these parameter grids and parallelizes the computation on a user specified number of CPU units. 

  1. *MakeTable()* creates LaTex tables from the output of *MonteCarlo()*. It stacks high dimensional output arrays into tables with a user specified ordering of rows and columns. 


| Argument | Description |
|:----------:|:---------------------------------------------|
| func | The function to be evaluated. |
| nrep | An integer that specifies the desired number of Monte Carlo repetitions. |
| param_list | A list whose components are named after the parameters of func and each component is a vector containing the desired grid values for that parameter |
| ncpus | An integer specifying the number of cpus to be used. Default is ncpus=1. For ncpus>1 the simulation is parallized automatically using ncpus cpu units. |
| max_grid | Integer that specifies for which grid size to throw an error, if grid becomes to large. Default is max_grid=1000. |
| time_n_test	| Boolean that specifies whether the required simulation time should be estimated (useful for large simulations or slow functions). See details. Default is time_n_test=FALSE.|
| save_res | Boolean that specifies whether the results of time_n_test should be saved to the current directory. Default is time_n_test=FALSE. |
| debug	| Boolean that activates/deactivates the debug mode. If debug=TRUE all relevant variables are assigned to the global environment and the core loop is printed. This allows to run it manually and to see how MonteCarlo works internally. Default is debug=FALSE. |
| raw | Boolean that specifies whether the output should be averaged over the nrep repetitions. Default is raw=TRUE. |


  
|   Argument  |   Description  |
|:----------:|:---------------------------------------------|
| output | list of class MonteCarlo generated by MonteCarlo |
| rows	| vector of parameter names to be stacked in the rows of the table. Ordered from inner to outer.|
| cols | vector of parameter names to be stacked in the cols of the table. Ordered from inner to outer.|
| digits | number of digits displayed in table. Default is digits=4.|
| collapse | optional list of the same length as output giving the names of functions to be applied to the repective components of output when collapsing the results to a table. By default means are taken. Another example could be sd().|
| transform | optional argument to transform the output table (for example from MSE to RMSE). If a function is supplied it is applied to all tables. Alternatively, a list of functions can be supplied that has the same length as output. For tables that are supposed to stay unchanged set list element to NULL. |
| include\_meta | booloean that determines whether the meta data provided by summary() is included in comments below the table. Default is include_meta==TRUE.|
| width_mult | scaling factor for width of the output table. Default is width_mult=1.|
| partial_grid | an optional list with the elements named after of the parameters for which only a part of the grid values is supposed to be included in the table. Each component of the list is a vector that specifies the grid values of interest.|

  
To use the package, only the data generation for a single draw and the application of the method (or model) to this draw have to be nested in a wrapper function that is passed to *MonteCarlo()* along with the parameter grid of interest. 

## A First Example

The best way to get working with the MonteCarlo package is to look at an example. Here we evaluate the performance of a standard t-test of the hypothesis $H_0: \mu=0$ vs $H_1: \mu\neq0$. We are interested to see how the size and power of the test change with the sample size (*n*), the distance from the null hypothesis (*loc* for location) and the estimated standard deviation of the distribution (*scale*).

The test statistic is given by
$\frac{\bar x}{\hat \sigma}$,

where $\bar x$ and $\hat \sigma$ are the arithmetic mean and the standard deviation. The sample is generated from a normal distribution.

To conduct this analysis, we proceed as follows. First, we load the MonteCarlo package.

```{r eval=FALSE}
library(MonteCarlo)
```
```{r include=FALSE}
library(MonteCarlo)
```

Then define the following function.

```{r}
#########################################
##      Example: t-test

# Define function that generates data and applies the method of interest

ttest<-function(n,loc,scale){
  
  # generate sample:
    sample<-rnorm(n, loc, scale)
  
  # calculate test statistic:
    stat<-sqrt(n)*mean(sample)/sd(sample)
  
  # get test decision:
    decision<-abs(stat)>1.96
  
  # return result:
    return(list("decision"=decision))
}
```
As discussed above, *ttest()* is formulated in a way as if we only want to generate a single test decision. The arguments of the function are the parameters we are interested in. *ttest()* carries out 4 steps: 

  1. Draw a sample of *n* observations from a normal distribution with mean $\mu=loc$ and standard deviation $\sigma=scale$.
  1. Calculate the t-statistic.
  1. Determine the test decision.
  1. Return the desired result in form of a list.

We then define the combinations of parameters that we are interested in and collect them in a list. The elements of the lists must have the same names as the parameters for which we want to supply grids.

```{r}

# define parameter grid:

  n_grid<-c(50,100,250,500)
  loc_grid<-seq(0,1,0.2)
  scale_grid<-c(1,2)

# collect parameter grids in list:
  param_list=list("n"=n_grid, "loc"=loc_grid, "scale"=scale_grid)
```

To run the simulation, the function *ttest()* and the parameter grid (*param_list*) are passed to *MonteCarlo()*, together with the desired number of Monte Carlo repetitions (*nrep=1000*).

```{r eval=FALSE}
# run simulation:

  MC_result<-MonteCarlo(func=ttest, nrep=1000, param_list=param_list)
```

```{r include=FALSE}
  MC_result<-MonteCarlo(func=ttest, nrep=1000, param_list=param_list)
```

There is no further coding required. All the mechanics of the Monte Carlo experiment are handled by the *MonteCarlo()* function.

Calling summary produces a short information on the simulation.

```{r}

  summary(MC_result)
```

As one can see from the summary, the simulation results are stored in an array of dimension `c(4,6,2,1000)`, where the Monte Carlo repetitions are collected in the last dimension of the array. 

To summarize the results in a reasonable way and to include them as a table in a paper or report, we have to represent them in a matrix. This is handled by the *MakeTable()* function, that stacks the submatrices collected in the array in the rows and columns of a matrix and prints the result in the form of code to generate a Latex table. 

To determine in which order the results are stacked in rows and columns, we supply the function arguments*rows* and *cols* that are vectors of the names of the parameters in the order in which we want them to appear in the table, sorted from the inside to the outside. 

```{r}
# generate table:

  MakeTable(output=MC_result, rows="n", cols=c("loc","scale"), digits=2, include_meta=FALSE)
```

To change the ordering, just change the vectors *rows* and *cols*.

```{r}
# generate table:

  MakeTable(output=MC_result, rows=c("n","scale"), cols="loc", digits=2, include_meta=FALSE)

```

Now we can simply copy the code and add it to our paper, report or presentation. That is all. The user can focus on the design of the experiment he is interested in and the interpretation of the results.

We will now discuss the details of *MonteCarlo()* and *MakeTable()* and then give further results.